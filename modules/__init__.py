#!/usr/local/bin/python3

"""
This is the documentation for correlated_mutation_project. The functions below are
used in the execution of the different paths of main python. The main dependencies
of these module are the sys, os, math and Bio packages but all of them should be
present in a correct python instalation.
This module only contain documented functions used in the main script.
The authors of this module are Andreu Bofill and Marina Reixachs.
"""

                        ########################
                        #        Authors:      #
                        #     Andreu Bofill    #
                        #    Marina Reixachs   #
                        ########################

########################
#        Modules       #
########################
import os, sys, math, numpy as np
from Bio import SeqIO, Entrez, AlignIO
from Bio.Blast import NCBIWWW, NCBIXML
from Bio.Align.Applications import ClustalwCommandline
import plotly.plotly as py, plotly.graph_objs as go, plotly.tools as tls
import matplotlib.pyplot as plt

class BlastResult(object):
	"""
	Class used to store the blast results.
	"""
	def __init__(self, hit_id, organism, sequence, evalue):
		self.hit = hit_id
		self.evalue = evalue
		self.species = organism
		self.sequence = sequence

def is_fasta(infile):
	"""
	Checks if the input file is in fasta format.
	"""
	op_infile = open(infile, "r")
	for line in op_infile:
		if line.startswith(">"):
			fasta = True
		else:
			fasta = False
		break
	return fasta
	op_infile.close()

def exec_blast(infile, config_file, out_name):
	"""
	From an input file in fasta format, and given a configuration file,
	execute Blast software from NCBI web server and print the result in a xml output file.
	"""
	db, evalue = parse_config(config_file, "blast")
	try:
		input_open = open(infile, "r")
		input_open.close()
	except:
		raise IOError("Cannot open input file %s" %infile)

	if is_fasta(infile) == False:
			raise TypeError("Input file %s must be in fasta format" %infile)
	else:
		fasta_string = SeqIO.read(infile, format="fasta")
		result_handle = NCBIWWW.qblast("blastp", db, fasta_string.seq)
		output= out_name + ".xml"
		save_file = open(output, "w")
		save_file.write(result_handle.read())
		save_file.close()
		result_handle.close()
	return (output)

def parse_blast_XML(blast_xml, config_file):
	"""
	Reads the blast_xml file generated by exec_blast and extracts the hit id and evalue (lower among all hsp for each hit).
	The hit id is used to extract the sequence and the organism from the NCBI database. Finally a BlastResult object containing
	all this information (hit id, sequence, organism and evalue) is created.
	"""
	blast_xml_op = open (blast_xml, 'r')
	Entrez.email = parse_config(config_file, "email")
	db, evalue = parse_config(config_file, "blast")

	for record in NCBIXML.parse(blast_xml_op):
		for align in record.alignments:
			hit_id = align.hit_id.split("|")
			prev_eval = 1
			for hsp in align.hsps:
				if hsp.expect < prev_eval:
					prev_eval = hsp.expect
			efetch = Entrez.efetch(db="protein", id=hit_id, rettype="fasta")
			for line in efetch:
				line = line.rstrip()
				if line.startswith(">"):
					id_info = line
					sequence = ""
				else:
					sequence += line
			sequence += line

			organism = id_info[id_info.find("[") + 1:id_info.find("]")]
			organism = organism.split()
			if len(organism) != 1:
				species = str(organism[0] + "_" + organism[1])

			if prev_eval <= float(evalue):
				yield BlastResult(hit_id[1], species, sequence, prev_eval)

def get_sequences(input1, blast_xml, output, config_file, blast_xml_2 = False, input2=False):
	"""
	For a single protein it generates a multifasta file with one single sequence of each organism,
	the one with lower evalue. For two proteins it generates two multifasta files also with a single
	sequence of each organism and the same organisms appear in both files.
	"""
	species = set()
	final_results = []
	results_id = 0
	for result in parse_blast_XML(blast_xml, config_file):
		results_id += 1
		if result.species not in species:
			final_results.append(result)
			species.add(result.species)
		else:
			[ result for element in final_results if element.species == result.species and result.evalue < element.evalue]

	if blast_xml_2 == False:
		outfile = output +".mfa"
		op_outfile = open(outfile, 'w')
		infile = open(input1, 'r')
		for line in infile:
			op_outfile.write(line)
		op_outfile.write("\n")

		for element in final_results:
			sentence = "> "+ element.species + "|"+ element.hit + "| \n" + element.sequence + "\n"
			op_outfile.write(sentence)
		op_outfile.close()
		print("\t%s hits found. After filtering, we have %s hits.\n" % (results_id,len(final_results)), file=sys.stderr)
		return (outfile)

	else:
		species_2 = set()
		final_results_2 = []
		results_id_2 = 0
		for result in parse_blast_XML(blast_xml_2, config_file):
			results_id_2 += 1
			if result.species not in species_2:
				final_results_2.append(result)
				species_2.add(result.species)
			else:
				[ result for element in final_results_2 if element.species == result.species and result.evalue < element.evalue]

		final_species = species.intersection(species_2)

		filtered_results = [element for element in final_results if element.species in final_species]
		filtered_results_2 = [element for element in final_results_2 if element.species in final_species]

		print("\n\tWith the first protein, we found %s hits, and after filtering, %s." % (results_id,len(filtered_results)), file=sys.stderr)
		print("\tWith the Second protein, we found %s hits, and after filtering, %s.\n" % (results_id_2,len(filtered_results_2)), file=sys.stderr)

		outfile1 = output +"_1.mfa"
		op_outfile1 = open(outfile1, 'w')
		infile1 = open(input1, 'r')
		for line in infile1:
			op_outfile1.write(line)
		op_outfile1.write("\n")

		for element in filtered_results:
			sentence = "> "+ element.species + "|"+ element.hit + "| \n" + element.sequence + "\n"
			op_outfile1.write(sentence)
		op_outfile1.close()

		outfile2 = output +"_2.mfa"
		op_outfile2 = open(outfile2, 'w')
		infile2 = open(input2, 'r')
		for line in infile2:
			op_outfile2.write(line)
		op_outfile2.write("\n")

		for element in filtered_results_2:
			sentence = "> "+ element.species + "|"+ element.hit + "| \n" + element.sequence + "\n"
			op_outfile2.write(sentence)
		op_outfile2.close()

		return (outfile1, outfile2)

def clustalW(infil, config_file, prefix):
	"""
	This method run ClustalW software and extract a multiple sequence alignment (MSA) from a multiple fasta file. We
	need to especify the path of the clustalW program in our computers in our configuration file.  The MSA is saved
	in a .aln file.
	"""
	clustalw_path = parse_config(config_file, "clustalw")
	try:
		op_infil = open(infil, "r")
		op_infil.close()
	except:
		raise IOError("Cannot open multifasta %s to perform the MSA" %infil)
	cline = ClustalwCommandline(clustalw_path, infile=infil, align="input", outfile=prefix, seqnos="ON", outorder="input", type="PROTEIN")
	stdout, stderr = cline()

def read_clustalw(clustalw_file):
	"""
	Read the MSA generated from ClustalW and save it to a new variable. This method calls another method, transpose_alignemnt
	mentioned below. It allows us to work with this alignemnt in a easier way.
	"""
	clustalw = open(clustalw_file, 'r')
	align = AlignIO.read(clustalw, "clustal")
	transposed = transpose_alignment(align)
	return transposed

def transpose_alignment(align):
	"""
	From a MSA, transpose all columns and rows, such that the columns in the alignment are saved as elements in a list. So
	finally we have a list of columns as strings.
	"""
	index = range(len(align[0]))
	transposed_gap = list()
	transposed = list()
	for i in index:
		transposed.append(''.join([seq[i] for seq in align]))
	for column in transposed:
		gap = 0
		if column[0] != "-":
			transposed_gap.append(column)
	return transposed_gap


def mutual_information(transposed, transposed_2 = False):
	"""
	Calculates MI scores between all positions in a single protein or two different proteins
	from the transposed MSA columns and returns a list with the scores for all possible pair
	of positions.
	MI = sum_i(sum_j( H(i) + H(j) - H(i,j) ))
	"""
	mi = []
	length = range(len(transposed))
	for i in length:
		entropy_i = entropy(transposed[i])
		mi_list = []
		if transposed_2 == False:
			for j in length:
				entropy_j = entropy(transposed[j])
				joint = joint_entropy(transposed[i], transposed[j])
				mi_calc = entropy_i + entropy_j - joint
				mi_list.append(mi_calc)
			mi.append(mi_list)

		else:
			length_2 = range(len(transposed_2))
			for j in length_2:
				entropy_j = entropy(transposed_2[j])
				joint = joint_entropy(transposed[i], transposed_2[j])
				mi_calc = entropy_i + entropy_j - joint
				mi_list.append(mi_calc)
			mi.append(mi_list)
	return mi


def entropy(column_string):
	"""
	Calculates the entropy of a single column(position) in the transposed MSA.
	H(i) = -sum_x(P(x)ln2(P(x)))
	"""
	frequencies = dict()
	total = len(column_string)
	entropy = 0
	for i in column_string:
		if i in frequencies:
			frequencies[i] +=1
		else:
			frequencies[i] = 1

	for key in frequencies:
		frequencies[key] /= total
		entropy += frequencies[key]*math.log(frequencies[key], 2)
	return -entropy


def joint_entropy(column_i, column_j):
	"""
	Calculates the joint entropy for two columns(positions) in the transposed MSA.
	H(i,j) = -sum_x(sum_y( P(x,y)ln2(P(x,y)) ))
	"""
	if len(column_i) != len(column_j):
		raise IndexError("The two MSA should have the same number of related sequences (same species)")
	freq_ij = dict()
	total = len(column_i)
	entropy = 0
	for index in range(total):
		i = column_i[index]
		j = column_j[index]
		if i+j in freq_ij:
			freq_ij[i+j] +=1
		else:
			freq_ij[i+j] = 1

	for key in freq_ij:
		freq_ij[key] /= total
		entropy += freq_ij[key]*math.log(freq_ij[key], 2)
	if entropy != 0.0:
		return -entropy
	else:
		return entropy

def write_mi_output(mi, output, filtered):
	"""
	From the given list of list with the mutual information values writes a tab separated format output such that:

		position_i	position_j	mi_value

	When the input is a single protein both position columns will refer to the same protein. If two different proteins
	are given as input, the first position column will refer to positions in the first protein and the second column to
	positions in the second protein.
	If a cut off value is specified it will only retrieve pairs of positions with MI values higher than the cut off.
	"""

	op_outfile = open(output, "w")
	op_outfile.write("###correlated mutations output file\n###Contains mutual information values for each pair of sequences\n\n")

	if filtered == 0.0:
		op_outfile.write("#pos1\tpos2\tMI\n")
		for index1 in range(len(mi)):
			position = mi[index1]
			for index2 in range(len(position)):
				op_outfile.write("%d\t%d\t%.5f\n" %(index1 + 1, index2 + 1, position[index2]))
	else:
		op_outfile.write("###FILTERING CUT OFF: %.2f\n" %filtered)
		op_outfile.write("#pos1\tpos2\tMI\n")
		for index1 in range(len(mi)):
			position = mi[index1]
			for index2 in range(len(position)):
				if position[index2] >= filtered:
					op_outfile.write("%d\t%d\t%.5f\n" %(index1 + 1, index2 + 1, position[index2]))
	op_outfile.close()

def plot_heatmap(mi, output):
	"""
	Given a list with the MI scores for all possible pairs of residues in the protein(s) sequence(s)
	plots a heatmap using matplotlib with the MI scores for each pair and saves it in PDF format.
	The axis represent the positions in the sequence and the legend includes the color scale for MI values.
	"""
	fig = plt.figure()
	data = np.array(mi)
	fig, ax = plt.subplots()
	heatmap = ax.pcolor(data, cmap=plt.cm.jet)

	ax.invert_yaxis()
	ax.xaxis.tick_top()

	ax.set_xlabel('Seq 2')
	ax.set_ylabel('Seq 1')
	ax.xaxis.set_label_position('top')

	ax.set_xlim(0, len(mi[0]))
	ax.set_ylim(len(mi), 0)

	xmajor_ticks = np.arange(0, len(mi[1]), 20)
	xminor_ticks = np.arange(0, len(mi[1]), 1)

	ymajor_ticks = np.arange(0, len(mi), 20)
	yminor_ticks = np.arange(0, len(mi), 1)

	ax.tick_params(axis = 'both', which = 'major', labelsize = 5)
	ax.tick_params(axis = 'both', which = 'minor', labelsize = 0)

	ax.set_xticks(xmajor_ticks)
	ax.set_xticks(xminor_ticks, minor = True)
	ax.set_yticks(ymajor_ticks)
	ax.set_yticks(yminor_ticks, minor = True)

	ax.tick_params(which = 'both', direction = 'out')

	plt.xticks(rotation=90)

	cb = plt.colorbar(heatmap)
	cb.set_label('MI value')

	fig.savefig(output, dpi = 700)

def plotly_heatmap(mi, output, config_file):
	"""
	Given a list with the MI scores for all possible pairs of residues in the protein(s) sequence(s)
	creates a plotly heatmap.
	"""
	(username, api_key)= parse_config(config_file, "plotly")
	tls.set_credentials_file(username=username, api_key=api_key)
	data = [ go.Heatmap(
			z=mi,
			x=[i for i in range(len(mi))],
			y= [i for i in range(len(mi))]) ]
	plot_url = py.plot(data, filename = output)

def parse_config (config_file, option):
	"""
	This method is used to read the configuration file to extract the necesary information for each part of the program
	"""
	op_config = open(config_file, "r")
	if option == "blast":
		for line in op_config:
			if line.startswith("blast"):
				line = line.split("\t")
				db = line[1].strip()
				evalue = line[2].strip()
				return(db, evalue)

	elif option == "clustalw":
		for line in op_config:
			if line.startswith ("clustalw"):
				line = line.split("\t")
				clustal_path = line[1].strip()
				return (clustal_path)

	elif option == "plotly":
		for line in op_config:
			if line.startswith("plotly"):
				line = line.split("\t")
				username = line[1].strip()
				api_key = line[2].strip()
				return (username, api_key)

	elif option == "email":
		for line in op_config:
			if line.startswith("Entrez_email"):
				line = line.split("\t")
				mail = line[1].strip()
				return (mail)
	elif option == "root":
		for line in op_config:
			if line.startswith("root"):
				line = line.split("\t")
				root = line[1].strip()
				return (root)

def input_name(inputname):
	"""
	This function is used to extract the name of the input file, to be used if an output name is not given
	"""
	path= (os.path.abspath(inputname))
	return (path.split("/")[-1].split(".")[0])
